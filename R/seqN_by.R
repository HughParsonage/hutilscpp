#' Running per group identification
#' @description Within-group row-id and size of a sorted vector.
#'
#' @param x A sorted, integer vector.
#' @param check Whether to check whether \code{x} is sorted.
#' @param seqN A sequence formed from \code{seqN_by}.
#' @param DT A \code{data.table} with at least one \code{key}.
#' @param cols A length-two character vector, the names of the \code{seqN}
#' and \code{N} columns.
#'
#'
#' @return
#' For a sorted, integer \code{x}:
#'
#' \describe{
#' \item{\code{seqN_by}}{For every run of constant \code{x} the sequence
#' \code{1, ..., N} where \code{N} is the size of the group. Equivalent to \code{rowid}
#' in the \code{data.table} package.}
#' \item{\code{seqN_to_N}}{Accepts a sequence generated by \code{seqN_by} and
#' returns the sizes of the original group.}
#' \item{\code{mutate_seqN_N}}{Accepts a \code{data.table} and appends the
#' \code{seqN} and \code{N} columns.}
#' }
#'
#'
#' @export

seqN_by <- function(x, check = TRUE) {
  stopifnot(is.integer(x))
  if (!isFALSE(check) && isntSorted(x, asc = TRUE)) {
    stop("`x` was not sorted.")
  }
  .Call("Ccumsum_reset_sorted_int", x, PACKAGE = packageName)
}

#' @rdname seqN_by
#' @export
seqN_to_N <- function(seqN, check = TRUE) {
  .Call("C_seqN_to_N", seqN, check, PACKAGE = packageName)
}

#' @rdname seqN_by
#' @export
mutate_seqN_N <- function(DT, cols = c("seqN", "N"), check = TRUE) {
  stopifnot(haskey(DT), is.character(cols), length(cols) == 2L)
  set(DT, j = cols[1], value = seqN_by(.subset2(DT, key(DT)[1]), check = check))
  set(DT, j = cols[2], value = seqN_to_N(.subset2(DT, cols[1]), check = FALSE))
  DT[]
}
