# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

AnyCharMatch <- function(x, a, opposite = FALSE) {
    .Call(`_hutilscpp_AnyCharMatch`, x, a, opposite)
}

#' @title Quickly verify (and locate) the existence of a breach.
#' @name AnyWhich
#' @description Used when a single instance is likely to occur and be important to detect quickly
#' (in a sufficiently large integer vector).
#' @param x An integer vector.
#' @param a A (single) integer. That which is to be compared.
#' @param gt,lt,eq Booleans, whether or not the comparison is greater than, less than, or equal to.
#' Only \code{gt} and \code{lt} are mutually exclusive. If all \code{FALSE}, find the first instance
#' where none are equal (i.e. does \code{x} have more than one distinct value).
#' @noRd
NULL

AnyWhich_dbl <- function(x, a, gt, lt, eq, rev = FALSE) {
    .Call(`_hutilscpp_AnyWhich_dbl`, x, a, gt, lt, eq, rev)
}

AnyWhich_int <- function(x, a, gt, lt, eq, rev = FALSE) {
    .Call(`_hutilscpp_AnyWhich_int`, x, a, gt, lt, eq, rev)
}

AnyWhichInDbl <- function(x, Table) {
    .Call(`_hutilscpp_AnyWhichInDbl`, x, Table)
}

AnyWhichInInt <- function(x, Table) {
    .Call(`_hutilscpp_AnyWhichInInt`, x, Table)
}

Implies <- function(x, y, anyNAx = TRUE, anyNAy = TRUE) {
    .Call(`_hutilscpp_Implies`, x, y, anyNAx, anyNAy)
}

anyOutside_int <- function(x, a, b, nas_present = FALSE, na_is_outside = TRUE) {
    .Call(`_hutilscpp_anyOutside_int`, x, a, b, nas_present, na_is_outside)
}

anyOutside_dbl <- function(x, a, b, nas_present = FALSE, na_is_outside = TRUE) {
    .Call(`_hutilscpp_anyOutside_dbl`, x, a, b, nas_present, na_is_outside)
}

do_range_dbl <- function(x, halt_if_min = 1, halt_if_max = -1) {
    .Call(`_hutilscpp_do_range_dbl`, x, halt_if_min, halt_if_max)
}

do_range_int <- function(x, halt_if_min = 1L, halt_if_max = -1L) {
    .Call(`_hutilscpp_do_range_int`, x, halt_if_min, halt_if_max)
}

do_cumsum_reset_logical <- function(x) {
    .Call(`_hutilscpp_do_cumsum_reset_logical`, x)
}

do_cumsum_reset_integer <- function(x, y) {
    .Call(`_hutilscpp_do_cumsum_reset_integer`, x, y)
}

do_cumsum_reset_double <- function(x, y) {
    .Call(`_hutilscpp_do_cumsum_reset_double`, x, y)
}

do_duplicated_sorted_int <- function(x) {
    .Call(`_hutilscpp_do_duplicated_sorted_int`, x)
}

do_duplicated_sorted_dbl <- function(x) {
    .Call(`_hutilscpp_do_duplicated_sorted_dbl`, x)
}

do_cumsum_reset_sorted_int <- function(x) {
    .Call(`_hutilscpp_do_cumsum_reset_sorted_int`, x)
}

do_are_even <- function(x, y) {
    .Call(`_hutilscpp_do_are_even`, x, y)
}

do_which_even <- function(x, y) {
    .Call(`_hutilscpp_do_which_even`, x, y)
}

do_range_dbl_simple <- function(x) {
    .Call(`_hutilscpp_do_range_dbl_simple`, x)
}

do_anyNonfinite <- function(x) {
    .Call(`_hutilscpp_do_anyNonfinite`, x)
}

do_which_first <- function(x) {
    .Call(`_hutilscpp_do_which_first`, x)
}

do_which_last <- function(x) {
    .Call(`_hutilscpp_do_which_last`, x)
}

do_which_first_false <- function(x) {
    .Call(`_hutilscpp_do_which_first_false`, x)
}

do_which_first_int_int <- function(x, y, eq = TRUE, gt = FALSE, lt = FALSE) {
    .Call(`_hutilscpp_do_which_first_int_int`, x, y, eq, gt, lt)
}

do_which_first_lgl_lgl <- function(x, y, eq, lt, gt, skip_na = FALSE) {
    .Call(`_hutilscpp_do_which_first_lgl_lgl`, x, y, eq, lt, gt, skip_na)
}

do_which_1st_uneq_dbl_dbl <- function(x, y, tol) {
    .Call(`_hutilscpp_do_which_1st_uneq_dbl_dbl`, x, y, tol)
}

do_which_1st_uneq_int_int <- function(x, y) {
    .Call(`_hutilscpp_do_which_1st_uneq_int_int`, x, y)
}

do_xor2 <- function(x, y, anyNAx = TRUE, anyNAy = TRUE) {
    .Call(`_hutilscpp_do_xor2`, x, y, anyNAx, anyNAy)
}

showValue <- function(what, x) {
    invisible(.Call(`_hutilscpp_showValue`, what, x))
}

haversine_distance <- function(olat1, olon1, olat2, olon2, unitless = FALSE) {
    .Call(`_hutilscpp_haversine_distance`, olat1, olon1, olat2, olon2, unitless)
}

haversineDistance <- function(lat1, lon1, lat2, lon2, unitless = FALSE) {
    .Call(`_hutilscpp_haversineDistance`, lat1, lon1, lat2, lon2, unitless)
}

theEuclidDistance <- function(x1, x2, y1, y2, unitless = FALSE) {
    .Call(`_hutilscpp_theEuclidDistance`, x1, x2, y1, y2, unitless)
}

hausdorffEuclid <- function(x, y) {
    .Call(`_hutilscpp_hausdorffEuclid`, x, y)
}

EmptiestQuarter <- function(x, y, minx = 1, maxx = -1, miny = 1, maxy = -1) {
    .Call(`_hutilscpp_EmptiestQuarter`, x, y, minx, maxx, miny, maxy)
}

theEmptiestQuarters <- function(x, y, minx = 1, maxx = -1, miny = 1, maxy = -1, depth = 4L) {
    .Call(`_hutilscpp_theEmptiestQuarters`, x, y, minx, maxx, miny, maxy, depth)
}

which_min_HaversineDistance <- function(lat1, lon1, lat2, lon2, upperBound = 10) {
    .Call(`_hutilscpp_which_min_HaversineDistance`, lat1, lon1, lat2, lon2, upperBound)
}

match_min_Haversine <- function(lat1, lon1, lat2, lon2, tabl, cartR = -1, dist0_km = 0.01, verify_cartR = FALSE, do_verify_box = FALSE, excl_self = FALSE, ncores = 1L) {
    .Call(`_hutilscpp_match_min_Haversine`, lat1, lon1, lat2, lon2, tabl, cartR, dist0_km, verify_cartR, do_verify_box, excl_self, ncores)
}

is_safe2int <- function(x, int_max) {
    .Call(`_hutilscpp_is_safe2int`, x, int_max)
}

force_as_integer <- function(x, na_code) {
    .Call(`_hutilscpp_force_as_integer`, x, na_code)
}

is_sorted_ascending_dbl <- function(x) {
    .Call(`_hutilscpp_is_sorted_ascending_dbl`, x)
}

is_sorted_descending_dbl <- function(x) {
    .Call(`_hutilscpp_is_sorted_descending_dbl`, x)
}

is_sorted_ascending_int <- function(x) {
    .Call(`_hutilscpp_is_sorted_ascending_int`, x)
}

is_sorted_descending_int <- function(x) {
    .Call(`_hutilscpp_is_sorted_descending_int`, x)
}

is_sorted_int <- function(x) {
    .Call(`_hutilscpp_is_sorted_int`, x)
}

do_isntSorted_int <- function(x) {
    .Call(`_hutilscpp_do_isntSorted_int`, x)
}

is_sorted_dbl <- function(x) {
    .Call(`_hutilscpp_is_sorted_dbl`, x)
}

do_isntSorted_dbl <- function(x) {
    .Call(`_hutilscpp_do_isntSorted_dbl`, x)
}

do_or3 <- function(x, y, z) {
    .Call(`_hutilscpp_do_or3`, x, y, z)
}

do_and3 <- function(x, y, z) {
    .Call(`_hutilscpp_do_and3`, x, y, z)
}

na_and <- function(x) {
    .Call(`_hutilscpp_na_and`, x)
}

do_which3 <- function(x, y, z, And = TRUE, anyNAx = TRUE, anyNAy = TRUE, anyNAz = TRUE) {
    .Call(`_hutilscpp_do_which3`, x, y, z, And, anyNAx, anyNAy, anyNAz)
}

do_which3_mem <- function(x, y, z, And = TRUE) {
    .Call(`_hutilscpp_do_which3_mem`, x, y, z, And)
}

do_pmax0_abs_dbl <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmax0_abs_dbl`, x, in_place)
}

do_pmin0_abs_dbl <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_abs_dbl`, x, in_place)
}

do_pmax0_abs_int <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmax0_abs_int`, x, in_place)
}

do_pmin0_abs_int <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_abs_int`, x, in_place)
}

do_firstNonNegativeRadix_int <- function(x, mini = 0L, maxi = -1L, desc = FALSE, depth = 0L) {
    .Call(`_hutilscpp_do_firstNonNegativeRadix_int`, x, mini, maxi, desc, depth)
}

do_firstNonNegativeRadix_dbl <- function(x, mini = 0L, maxi = -1L, desc = FALSE, depth = 0L) {
    .Call(`_hutilscpp_do_firstNonNegativeRadix_dbl`, x, mini, maxi, desc, depth)
}

do_pmax0_radix_sorted_dbl <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmax0_radix_sorted_dbl`, x, in_place)
}

do_pmin0_radix_sorted_dbl <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_radix_sorted_dbl`, x, in_place)
}

do_pmin0_radix_sorted_int <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_radix_sorted_int`, x, in_place)
}

do_pmax0_radix_sorted_int <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmax0_radix_sorted_int`, x, in_place)
}

#' @name do_pmaxC
#' @title Internal pmaxC helpers
#' @description Internal functions used when the overheads of assertions
#' would be too expensive. The \code{_IP_} flavours modify in place.
#' @param x A numeric/integer vector.
#' @param a A single numeric/integer.
#' @param in_place Modify \code{x} in place?
#' @export do_pmaxC_dbl do_pmaxC_int do_pmax0 do_pmaxIPint0 do_pmaxIPnum0
NULL

#' @rdname do_pmaxC
do_pmaxC_dbl <- function(x, a, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmaxC_dbl`, x, a, in_place)
}

#' @rdname do_pmaxC
do_pmaxC_int <- function(x, a, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmaxC_int`, x, a, in_place)
}

#' @rdname do_pmaxC
do_pmax0 <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmax0`, x, in_place)
}

do_pmaxIP_int <- function(x, a) {
    .Call(`_hutilscpp_do_pmaxIP_int`, x, a)
}

do_pmaxIP_dbl <- function(x, a) {
    .Call(`_hutilscpp_do_pmaxIP_dbl`, x, a)
}

#' @rdname do_pmaxC
do_pmaxIPnum0 <- function(x) {
    .Call(`_hutilscpp_do_pmaxIPnum0`, x)
}

#' @rdname do_pmaxC
do_pmaxIPint0 <- function(x) {
    .Call(`_hutilscpp_do_pmaxIPint0`, x)
}

#' @title Parallel maximum in C++
#' @description A faster \code{pmax()}.
#'
#' @name do_pmaxV
#' @param x A numeric vector.
#' @param y A numeric vector, the same length as x.
#' @param in_place (bool, default: \code{false}) Should the function operate on \code{x} in-place?
#' @return The parallel maximum of the input values.
#' @export do_pmaxNumNum do_pmaxIntInt
NULL

#' @rdname do_pmaxV
do_pmaxNumNum <- function(x, y, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmaxNumNum`, x, y, in_place)
}

#' @rdname do_pmaxV
do_pmaxIntInt <- function(x, y, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmaxIntInt`, x, y, in_place)
}

#' @title Parallel maximum
#' @description A faster \code{pmin()}.
#'
#' @name do_pminC
#' @param x A numeric vector.
#' @param a A single numeric value.
#' @param in_place (bool, default: \code{false}) Should the function operate on \code{x} in-place?
#' @return The parallel minimum of the input values. The \code{0} versions are shortcuts for \code{a = 0}.
#' @note This function will always be faster than \code{pmin(x, a)} when \code{a} is a single value, but can be slower than \code{pmin.int(x, a)} when \code{x} is short. Use this function when comparing a numeric vector with a single value.
#' @export do_pminC
NULL

do_pminC <- function(x, a, in_place = FALSE) {
    .Call(`_hutilscpp_do_pminC`, x, a, in_place)
}

do_pminC_int <- function(x, a, in_place = FALSE) {
    .Call(`_hutilscpp_do_pminC_int`, x, a, in_place)
}

do_pmin0_dbl <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_dbl`, x, in_place)
}

do_pmin0_int <- function(x, in_place = FALSE) {
    .Call(`_hutilscpp_do_pmin0_int`, x, in_place)
}

#' @title Parallel maximum
#' @description A faster \code{pmin()}.
#'
#' @name do_pminV
#' @param x A numeric vector.
#' @param y A numeric vector, the same length as x.
#' @param in_place (bool, default: \code{false}) Modify \code{x} in-place?
#' @return The parallel maximum of the input values.
#' @export do_pminV_dbl do_pminV_int
NULL

#' @rdname do_pminV
do_pminV_dbl <- function(x, y, in_place = FALSE) {
    .Call(`_hutilscpp_do_pminV_dbl`, x, y, in_place)
}

#' @rdname do_pminV
do_pminV_int <- function(x, y, in_place = FALSE) {
    .Call(`_hutilscpp_do_pminV_int`, x, y, in_place)
}

squishn <- function(x, a, b, in_place = FALSE) {
    .Call(`_hutilscpp_squishn`, x, a, b, in_place)
}

squishi <- function(x, a, b, in_place = FALSE) {
    .Call(`_hutilscpp_squishi`, x, a, b, in_place)
}

sum_isna_int <- function(x) {
    .Call(`_hutilscpp_sum_isna_int`, x)
}

sum_isna_dbl <- function(x) {
    .Call(`_hutilscpp_sum_isna_dbl`, x)
}

sum_isna_complx <- function(x) {
    .Call(`_hutilscpp_sum_isna_complx`, x)
}

sum_isna_char <- function(x) {
    .Call(`_hutilscpp_sum_isna_char`, x)
}

sum_isfalse <- function(x) {
    .Call(`_hutilscpp_sum_isfalse`, x)
}

sum_isna_logi <- function(x) {
    .Call(`_hutilscpp_sum_isna_logi`, x)
}

do_summary3_dbl <- function(x, y, z, in_place = FALSE, do_max = TRUE) {
    .Call(`_hutilscpp_do_summary3_dbl`, x, y, z, in_place, do_max)
}

do_summary3_int <- function(x, y, z, in_place = FALSE, do_max = TRUE) {
    .Call(`_hutilscpp_do_summary3_int`, x, y, z, in_place, do_max)
}

extractMandatory <- function(x, command, nCommands) {
    .Call(`_hutilscpp_extractMandatory`, x, command, nCommands)
}

do_which_true_onwards <- function(x) {
    .Call(`_hutilscpp_do_which_true_onwards`, x)
}

